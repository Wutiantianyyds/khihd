<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./js/vue.min.js"></script>
  </head>
  <body></body>
  <script>
    //字面量形式创建 缺点：如果重复创建与该对象同类型的对象，会产生大量重复的代码。
    // var obj = {
    //   name: "wu",
    //   age: 22,
    // };

    //  2.内置构造函数
    //内置构造函数
    // var obj1 = new Object();
    // obj1.name = "wu";
    // obj1.age = 22;
    // 缺点：如果重复创建与该对象同类型的对象，会产生大量重复的代码。

    //3.工厂模式 优点：解决了重复实例化多个对象的问题 缺点：对象没有一个具体的类型、都是Object类型。
    // function Obj(name, age) {
    //   var obj = new Object();
    //   obj.name = name;
    //   obj.age = age;
    //   obj.show = function () {
    //     console.log(this.name);
    //   };
    //   return obj;
    // }
    // var obj = Obj("wu", 22);

    //自定义构造函数 自定义构造函数时new的的原理：
    // 1. 创建一个新对象
    // 2. 改变函数内的this指向，为这个新对象
    // 3. 执行函数内的代码，并将新对象的__proto__指向该函数的prototype
    // 4. 检查函数是否主动返回对象，如果没有，则返回这个新对象

    // 优点：解决重复实例化问题，又解决对象识别问题。

    // 缺点： 每个对象都有相同的数据（方法），浪费内存。请附上原文出处链接及本声明。
    // function Obj(name, age) {
    //   this.name = name;
    //   this.age = age;
    //   this.show = function () {
    //     console.log(this.name);
    //   };
    // }
    // var obj = new Obj("wu", 22);

    // 5.原型函数
    //原型函数
    function Obj(name) {
      this.name = name;
    }
    Obj.prototype = {
      constructor: Obj,
      show: function () {
        alert(this.name);
      },
    };
    var obj = new Obj("wu");
    // 优点：所有对象实例共享它的属性和方法，不浪费内存资源。

    //  ps：属性直接写在构造函数体内，方法写在构造函数的原型上。
  </script>
</html>
